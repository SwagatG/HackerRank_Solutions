/*
PROBLEM:
The sequence of triangle numbers is generated by adding the natural numbers. So the 7'th triangle number would be 1+2+3+4+5+6+7 = 28. The first ten terms would be:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:
1: 1
3: 1, 3
6: 1, 2, 3, 6
10: 1, 2, 5, 10
15: 1, 3, 5, 15
21: 1, 3, 7, 21
28: 1, 2, 4, 7, 14, 28
 
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over N divisors?

Input 
First line T, the number of testcases. Each testcase consists of N in one line.

Output 
For each testcase, print the required answer in one line.

Constraints 
1 <= T <= 10
1 <= N <= 10^3

Sample input
4
1
2
3
4

Sample output
3
6
6
28
*/

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int t;
    cin >> t;
    int n[t], maxN = 0;
    for (int i = 0; i < t; i++){
        cin >> n[i];
        if (n[i] > maxN){
            maxN = n[i];
        }
    }
    long lowTri[maxN];
    for (long i = 0; i < maxN; i++){
        lowTri[i] = 0;
    }
    
    bool nums[125000] = {0};
    int primes[1250], primeCount = 0;
    nums[0] = 1;
    nums[1] = 1;
    for (int i = 2; i*i < 125000; i++){
        if (nums[i] == 0){
            for (int j = i*i; j < 125000; j += i){
                nums[j] = 1;
            }
        }
    }
    for (int i = 2; i < 125000; i++){
        if (nums[i] == 0){
            primes[primeCount] = i;
            primeCount ++;
        }
    }
    
    int currFactors, factors=0, currNum = 3, factoredNum;
    int alpha = 0;
    for (int i = 2; factors < maxN; i++){
        currNum = (i * (i+1)) / 2;
        factors = 1;
        currFactors = 1;
        factoredNum = currNum;
        for (int j = 0; primes[j]*primes[j] <= factoredNum; j++){
            alpha = j;
            if (factoredNum % primes[j] == 0){
                currFactors ++;
                factoredNum /= primes[j];
                j -= 1;
            } else {
                factors *= currFactors;
                currFactors = 1; 
            }
        }
        
        if (factoredNum != 1){
            if (factoredNum == primes[alpha]){
                currFactors++;
                factors *= currFactors;
            } else {
            	factors *= currFactors;
                factors *= 2;
            }
        }
        
        factors --;
        
        for (int j = 0; j < factors; j++){
            if (lowTri[j] == 0){
                lowTri[j] = currNum;
            }
        }
    }

    for (int i = 0; i < t; i++){
        cout << lowTri[n[i]-1] << endl;
    }
    
    return 0;
}
